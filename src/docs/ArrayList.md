## ArrayList

### 1. 배열의 특징 

배열과 같이 여러 데이터(자료)를 구조화해서 다루는 것을 자료 구조라 한다.

자바는 배열 뿐만 아니라, 컬렉션 프레임워크라는 이름으로 다양한 자료 구조를 제공한다.

컬렉션 프레임워크와 자료 구조를 설명하기 전에 먼저 자료 구조의 가장 기본이 되는 배열 특징을 알아보자. 

배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.

인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다. 

예를 들어서, 배열에 접근할 수 있는 참조값이 x100이라고 생각하면

2번 인덱스의 위치는 x100 + (자료의 크기(4byte) * 인덱스 위치(2)) = x108

배열의 경우 인덱스를 사용하면 한번의 계산으로 매우 효율적으로 자료의 위치를 찾을 수 있다. 

### 2. 배열의 검색

배열에 들어있는 데이터를 찾는 것을 검색이라 한다.

배열에 들어있는 데이터를 검색할 때는 배열에 들어있는 데이터를 하나하나 비교해야 한다.

이때는 이전과 같이 인덱스를 사용해서 한번에 찾을 수 없다.

대신에 배열 안에 들어있는 데이터를 하나하나 확인해야 한다.

따라서 평균적으로 볼 때 배열의 크기가 클 수록 오랜 시간이 걸린다.

ex) 배열의 크기 3: arr[0], arr[1], arr[2] 연산 3회..

ex) 배열의 크기 10: arr[0], arr[1], arr[2], ... , arr[9] 연산 10회..

크기가 커지면 클수록 연산 횟수는 더 늘어남. 배열의 크기만큼 늘어나므로

연산 횟수도 n만큼 필요함. 

### 3. 빅오 표기법

빅오 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식임. 

이는 특히 알고리즘이 처리해야 할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.

여기서 중요한 것은 데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이다.

빅오 표기법의 예시

- O(1) -> 상수 시간: 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정하다.

ex) 배열에서 인덱스를 사용하는 경우

- O(n) -> 선형 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.

ex) 배열의 검색, 배열의 모든 요소를 순회하는 경우

- O(n * n) : 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 제곱에 비례하여 증가한다.

ex) 보통 이중 루프를 사용하는 알고리즘에서 나타남

- 최적의 경우: 배열의 첫번째 항목에서 바로 값을 찾으면 O(1)이 된다.

- 최악의 경우: 마지막에 항목이 있거나 항목이 없는 경우 전체 요소를 순회한다. 이 경우 O(n)이 된다.

**배열 정리**

- 배열의 인덱스 사용: O(1)

- 배열의 순차 검색: O(n)

### 4. 배열의 특징2 - 데이터 추가

이번에는 배열의 특정 위치에 데이터를 추가해보자.

추가는 기존 데이터를 유지하면서 새로운 데이터를 입력하는 것을 뜻한다. 

참고로 데이터를 중간에 추가하면 기존 데이터가 오른쪽으로 한 칸씩 이동해야 한다.

데이터의 순서를 지키면서 추가할라면 기존 데이터들을 모두 오른쪽으로 한 칸씩 밀어서

추가할 위치를 확보해야 한다.

왼쪽의 데이터를 오른쪽에 대입하는 과정을 반복해야한다.

(오른쪽 끝에 있는 데이터들을 먼저 한 칸씩 밀어야함.)

만약에, 데이터를 실수로 앞에 있는걸 먼저 밀으면 그 뒤에 있는 데이터들이 사라짐.

뭐 예를 들어서, [1,2,3,4,0] 이란 배열이 있는데

여기서 맨 앞에 있는 1부터 오른쪽으로 밀면 [ ,1,2,3,4].. 이런식으로 되서 안된다.

### 5. 배열에 데이터를 추가할 때 위치에 따른 성능 변화

- 배열의 첫번째 위치에 추가 

-> 배열의 첫번째 위치를 찾는데는 인덱스를 사용하므로 O(1)이 걸린다.

-> 모든 데이터를 배열의 크기만큼 한 칸씩 이동해야 한다. O(n) 만큼의 시간이 걸린다. 

-> O(1 + n) => O(n)

- 배열의 중간 위치에 추가

-> 배열의 위치를 찾는데는 O(1)이 걸린다.

-> index의 오른쪽에 있는 데이터를 모두 한 칸씩 이동해야 한다. 따라서 평균 연산은 O(n/2)이 된다.

-> O(1 + n/2) => O(n)

- 배열의 마지막 위치에 추가

-> 이 경우 배열이 이동하지 않고 배열의 길이를 사용하면 마지막 인덱스에 바로 접근할 수 있으므로
한번의 계산으로 위치를 찾을 수 있고, 기존 배열을 이동하지 않으므로 O(1)이 된다.

### 6. 배열의 한계

배열은 가장 기본적인 자료 구조이고, 특히 인덱스를 사용할 때 최고의 효율이 나온다.

하지만 이런 배열에는 큰 단점이 있다.

바로 배열의 크기를 배열을 생성하는 시점에 미리 정해야 한다는 점이다. 

예를 들어서 이벤트를 하는데, 누구나 이벤트에 참여할 수 있고, 

이벤트가 끝나면 추첨을 통해서 당첨자를 정한다고 가정해보자.

이때 이벤트에 참여하는 사용자를 배열에 보관한다고 가정하자.

사용자들은 실시간으로 계속 추가된다.

이때 넉넉하게 길이가 1000인 배열을 사용했는데, 예상보다 이벤트 참여자가 많아서

100명을 넘게 된다면 더 많은 사용자가 이벤트에 참여하지 못하는 문제가 발생한다.

배열처럼 처음부터 정적으로 길이가 정해져있는 것이 아니라,

동적으로 언제든지 길이를 늘리고 줄일 수 있는 자료 구조가 있다면

편리할 것이다. 

### 7. 배열 리스트

배열의 경우 다음 2가지 불편함이 있다.

- 배열의 길이를 동적으로 변경할 수 없다.

- 데이터를 추가하기 불편하다.
  (데이터를 추가하는 경우 직접 오른쪽으로 한 칸씩 데이터를 밀어야 한다.)

배열의 이런 불편함을 해소하고 동적으로 데이터를 추가 할 수 있는 자료 구조를 List라 한다. 

List 자료 구조 -> 순서가 있고, 중복을 허용하는 자료 구조를 리스트라 한다. 

일반적으로 배열과 리스트는 구분해서 이야기한다. 

리스트는 배열보다 유연한 자료 구조로, 크기가 동적으로 변할 수 있다.

배열: 순서가 있고 중복을 허용하지만 크기가 정적으로 고정된다.

리스트: 순서가 있고 중복을 허용하지만 크기가 동적으로 변할 수 있다.

### 8. 배열 리스트의 빅오

- 데이터 추가

-> 마지막에 추가: O(1)
-> 앞, 중간에 추가: O(n)

- 데이터 삭제

-> 마지막에 삭제: O(1)
-> 앞, 중간에 삭제: O(n)

- 인덱스 조회: O(1)
- 데이터 검색: O(n)








 