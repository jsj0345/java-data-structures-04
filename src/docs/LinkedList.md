## LinkedList

### 1. 노드와 연결

배열 리스트의 단점

- 배열 리스트는 내부에 배열을 사용해서 데이터를 보관하고 관리한다.

- 이로 인해 단점이 생긴다.

- 뭐 예를 들어서 데이터를 추가 한다고 하면 배열을 동적으로 확장해야 하는 경우가 있다.

-> 이런 경우가 있다 보면 사용하지 않는 공간 낭비가 있을 것이다. 

**배열의 중간에 데이터를 추가한다면?**

배열의 앞이나 중간에 데이터를 추가하면 추가할 데이터의 공간을 확보하기 위해 기존 데이터들을 오른쪽으로 

이동해야 한다. 그리고 삭제의 경우에는 빈 공간을 채우기 위해 왼쪽으로 이동해야 한다.

이렇게 앞이나 중간에 데이터를 추가하거나 삭제하는 경우 많은 데이터를 이동 해야 하기 때문에 성능이 좋지 않다. 

낭비되는 메모리 없이 딱 필요한 만큼만 메모리를 확보해서 사용하고, 또 앞이나 중간에 데이터를 추가하거나 삭제할 때도

효율적인 자료 구조가 있는데 바로 노드를 만들고 각 노드를 서로 연결하는 방식이다. 

**노드 클래스**

public class Node {
  Object item;
  Node next;

  public Node(Object item) {
    this.item = item;
  }
  
}

노드 클래스는 내부에 저장할 데이터인 item과, 다음으로 연결할 노드의 참조인 next를 가진다.

이 노드 클래스를 사용해서 데이터 A,B,C를 순서대로 연결해보자.

먼저 Node 객체를 만들어보자. Node a = new Node("A"); // x001

이러면 a.item = "A"; 일거고 a.next -> null이다.

여기서 a.next = new Node("B"); 로하면 item이 B이고 next가 null로 초기화 된 또 다른 노드가 생긴다.

이 상태에서 a.next.next = new Node("C"); 노드에 다른 노드를 접근 할 수 있는 참조값이 next에 초기화 된다. 

이렇게 노드를 만들면 메모리 공간 낭비 없이 다른 노드에도 접근하기가 매우 쉽다. 

### 2. 직접 구현하는 연결 리스트

노드와 연결 구조를 통해서 리스트를 만들어보자.

이런 자료 구조를 연결 리스트라 한다.

참고로 링크드 리스트, 연결 리스트라는 용어를 둘다 사용한다.

연결 리스트는 배열 리스트의 단점인 메모리 낭비, 중간 위치의 데이터 추가에 대한 성능 문제를

어느정도 극복할 수 있다. 

순서가 있고, 중복을 허용하는 자료 구조를 리스트라 한다.

### 3. ArrayList와 LinkedList

- 인덱스 조회에서는? 

-> ArrayList는 O(1) , LinkedList는 O(n)

- 검색에서는?

-> ArrayList는 O(n) , LinkedList는 O(n)

- 앞에 추가(삭제)는?

-> ArrayList는 O(n), LinkedList는 O(1)

- 뒤에 추가 삭제는?

-> ArrayList는 O(1), LinkedList는 O(n)

- 평균 추가 삭제는?

-> ArrayList는 O(n) , LinkedList는 O(n)













